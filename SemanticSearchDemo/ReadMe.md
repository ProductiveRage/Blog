# Semantic Search Demo

This web app will read in the embeddings generated by the `GenerateSimilarityEmbeddings` project and allow you to search over the blog post data using the [bge-micro-v2](https://huggingface.co/TaylorAI/bge-micro-v2) semantic similarity model.

That embedding model effectively enables searching for the "most similar" results to a query, but the vector distances are only comparable in the context of that query - does this match seem to be better than that one? The similarity scores are not comparable across different searches, and there is no "threshold" minimum score that indicates "this is a good result". The results that you get might be the best matches, if there is good content for the query, or they might be the "least bad" matches.. all of which may feasibly be terrible. To improve that situation, the vector search results are fed to the Cohere `rerank-v3.5` model via an API call, as that _can_ assign reliable scores, so that we remove poor quality results.

To try it  out yourself, you'll need to go to [cohere.com](https://cohere.com) and sign up to get an API key (it's free!) and configure a `COHERE_API_KEY` environment variable. Then you'll need to run the `GenerateSimilarityEmbeddings` project, which will break up the blog post content from this repo, calculate embeddings, and write cache files to disk. _Then_ you may run this project, as it will copy those cache files in order to provide the search.

If you run this project without the cache files from `GenerateSimilarityEmbeddings` being available, you will see the message `Unknown Initialisation Error` in the web page when it starts up.

If you don't configure a Cohere API key, you will see the message `Reranker configuration missing` in the web page.

An alternative to setting an environment variable is to add an `appsettings.debug.json` file to the root of this project that contains the API key - it should look like this:

```
{
  "COHERE_API_KEY": "key-goes-here"
}
```

## In action

You can also see a version of this code at [search.productiverage.com](https://search.productiverage.com), though that does use a reranker stage instead of a similarity score threshold (I'll update the code here one day to match it!)

Although I created this blog repo as an MVC application many years ago, I have a process that translates it into the static version hosted on GitHub Pages today ([www.productiverage.com](https://www.productiverage.com)). The lexical search is performed client side, with the necessary indexed data part of the static GitHub Pages content (back in 2013, [I got all excited about the launch of neocities](https://www.productiverage.com/the-neocities-challenge-aka-the-full-text-indexer-goes-clientside) and tested the concept of a client-side search, and I use that now for my live site). In March 2025, I extended the JavaScript to also call [search.productiverage.com](https://search.productiverage.com) so that the search results contain both semantic and lexical results.

An example of a query that I see in Google Search Console that results in people be shown my blog is this:

> how to redirect to another controller action in mvc

The lexical search fails to find any matches (which makes me fear that there is an error with my stemming logic, since replacing the word "redirect" with "redirecting" results in a lexical match) but the *semantic* search does return the result, and so now performing that query on my own blog works - yay, hybrid search! [Try it here](https://www.productiverage.com/Search?term=how+to+redirect+to+another+controller+action+in+mvc).

## What's this code style all about?

A few years ago, I worked at a company that leant into a functional programming style of writing C#, and I had recently been discussing using something like an `Either<L, R>` class in C# code with a current colleague for handling errors. It had got me thinking about how fun it was, and it inspired me to give it another go, hence the slightly unusual (for C#) style in this project. What are personal projects for, if not to experiment!