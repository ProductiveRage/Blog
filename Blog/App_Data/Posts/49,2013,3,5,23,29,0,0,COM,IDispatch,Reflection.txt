## Supporting IDispatch through the COMInteraction wrapper

Some time ago, I wrote some code that would generate a wrapper to apply a given interface to any object using reflection. The target object would need to expose the properties and methods of the interface but may not implement the interface itself. This was intended to wrap some old WSC components that I was having to work with but is just as easy to demonstrate with .Net classes:

    using System;
    using COMInteraction.InterfaceApplication;
    using COMInteraction.InterfaceApplication.ReadValueConverters;

    namespace DemoApp
    {
      class Program
      {
        static void Main(string[] args)
        {
          // Warning: This code will not compile against the current code since the interface has changed
          // since the example was written but read on to find out how it's changed!
          // - Ok, ok, just replace "new InterfaceApplierFactory" with "new ReflectionInterfaceApplierFactory"
          //   and "InterfaceApplierFactory.ComVisibilityOptions.Visible" with "ComVisibilityOptions.Visible"
          //   :)
          var interfaceApplierFactory = new InterfaceApplierFactory(
            "DynamicAssembly",
            InterfaceApplierFactory.ComVisibilityOptions.Visible
          );
          var interfaceApplier = interfaceApplierFactory.GenerateInterfaceApplier<IAmNamed>(
            new CachedReadValueConverter(interfaceApplierFactory)
          );

          var person = new Person() { Id = 1, Name = "Teddy" };
          var namedEntity = interfaceApplier.Apply(person);
        }
      }

      public interface IAmNamed
      {
        string Name { get; }
      }

      public class Person
      {
        public int Id { get; set; }
        public string Name { get; set; }
      }
    }


The "namedEntity" reference implements IAmNamed and passes the calls through to the wrapped "Person" instance through reflection (noting  that Person does not implement IAmNamed). Of course, this will cause exceptions if an instance is wrapped that doesn't expose the properties or methods of the interface when those are called.

I wrote about the development of this across a few posts: [Dynamically applying interfaces to objects](Post15), [Part 2](Post16) and [Part 3](Post17) (with the code available at the [COMInteraction project on Bitbucket](https://bitbucket.org/DanRoberts/cominteraction)).

And this worked fine for the purpose at hand. To be completely frank, I'm not entirely sure *how* it worked when calling into the WSC components that expose a COM interface since I'm surprised the reflection calls are able to hook into the methods! It felt a bit hacky..

But just recently I've gotten into some of the nitty gritty of IDispatch (see [IDispatch (IWastedTimeOnThis but ILearntLots)](Post44)) and thought maybe I could bring this information to bear on this project.

### Supporting Reflection *and* IDispatch

The existing InterfaceApplierFactory class has been renamed to the **ReflectionInterfaceApplierFactory** and a new implementation of **IInterfaceApplierFactory** has been added: the **IDispatchInterfaceApplierFactory**. (Where do I come up with these catchy names?! :).

Where the existing (and now renamed) class generated IL to access the methods and properties through reflection, the new class generates IL to access the methods and properties using the code from my previous IDispatch post, handily wrapped up into a static **IDispatchAccess** class.

The code to do this wasn't too difficult to write, starting with the reflection-approach code as a template and writing the odd bit of test code to disassemble with ildasm if I found myself getting a bit lost.

While I was doing this, I changed the structure of the **ReflectionInterfaceApplierFactory** slightly - I had left a comment in the code explaining that properties would be defined for the type generated by the IL with getter and setter methods attached to it but that these methods would then be overwritten since the code that enumerates methods for the implemented interface(s) picks up "get\_" and "set\_" methods for each property. The comment goes on to say that this doesn't appear to have any negative effect and so hasn't been addressed. But with this revision I've gone a step further and removed the code the generates the properties entirely, relying solely on the "get\_" and "set\_" methods that are found in the interface methods as this seems to work without difficulty too! Even indexed properties continue to work as they get the methods "get\_Item" and "set\_Item" - if you have a class with an indexed property you may not also have a method named "Item" as you'll get a compilation error:

> "The type 'Whatever' already contains a definition for 'Item'

I'm not 100% confident at this point that what I've done here is correct and whether or not I'm relying on some conventions that may not be guaranteed in the future. But I've just received a copy of "CLR via C#" in the post so maybe I'll get a better idea of what's going on and amend this in the future if required!

The types generated by the **IDispatchInterfaceApplierFactory** will *not* work if properties are not explicitly defined (and so IL is emitted to do this properly in this case).

### Choosing Reflection, IDispatch (or neither)

Another new class is the **CombinedInterfaceApplierFactory** which is intended to take the decision-making out of the use of reflection / IDispatch. It will generate an **IInterfaceApplier** whose Apply method will apply an IDispatch wrapper if the object-to-wrap's type's IsCOMObject property is true. Otherwise it will use reflection. Actually, it performs a check before this to ensure that the specified object-to-wrap doesn't already implement the required interface - in which case it returns it straight back! (This was useful in some scenarios I was testing out and also makes sense; if the type doesn't require any manipulation then don't perform any).

### Not being Lazy

I realised, going back to this project, that I'd got over-excited when I discovered the Lazy&lt;T&gt; class in .Net 4 and used it when there was some work in the code that I wanted to defer until it was definitely required. But this, of course, meant that the code had a dependency on .Net 4! Since I imagine that this could be useful in place of the "dynamic" keyword in some cases, I figured it would make sense to try to remove this dependency. (My over-excitement is probably visible when I wrote about it at [Check, check it out](Post6)).

I was using it with the "threadSafe" option set to true so that the work would only be executed once (at most). This is a fairly straight forward implementation of the double-checked locking pattern (if there *is* such a thing! :) with a twist that if the work threw an exception then that exception should be thrown for not only the call on the thread that actually performed the work but also subsequent calls:

    using System;

    namespace COMInteraction.Misc
    {
      /// <summary>
      /// This is similar to the .Net 4's Lazy class with the isThreadSafe argument set to true
      /// </summary>
      public class DelayedExecutor<T> where T : class
      {
        private readonly Func<T> _work;
        private readonly object _lock;
        private volatile Result _result;
        public DelayedExecutor(Func<T> work)
        {
          if (work == null)
            throw new ArgumentNullException("work");

          _work = work;
          _lock = new object();
          _result = null;
        }

        public T Value
        {
          get
          {
            if (_result == null)
            {
              lock (_lock)
              {
                if (_result == null)
                {
                  try
                  {
                    _result = Result.Success(_work());
                  }
                  catch(Exception e)
                  {
                    _result = Result.Failure(e);
                  }
                }
              }
            }
            if (_result.Error != null)
              throw _result.Error;
            return _result.Value;
          }
        }

        private class Result
        {
          public static Result Success(T value)
          {
            return new Result(value, null);
          }
          public static Result Failure(Exception error)
          {
            if (error == null)
              throw new ArgumentNullException("error");
            return new Result(null, error);
          }
          private Result(T value, Exception error)
          {
            Value = value;
            Error = error;
          }

          public T Value { get; private set; }

          public Exception Error { get; private set; }
        }
      }
    }

### Conclusion

So finally, the project works with .Net 3.5 and can be used with only the following lines:

    var interfaceApplierFactory = new CombinedInterfaceApplierFactory(
      new ReflectionInterfaceApplierFactory("DynamicAssembly", ComVisibilityOptions.Visible),
      new IDispatchInterfaceApplierFactory("DynamicAssembly", ComVisibilityOptions.Visible)
    );
    var interfaceApplier = interfaceApplierFactory.GenerateInterfaceApplier<IWhatever>(
      new CachedReadValueConverter(interfaceApplierFactory)
    );
    var wrappedInstance = interfaceApplier.Apply(obj);

In real use, you would want to share generated Interface Appliers rather than creating them each time a new instance needs wrapping up in an interface but how you decide to handle that is down to you!*

\* (I've also added a **CachingInterfaceApplierFactory** class which can be handed to multiple places to easily enable the sharing of generated Interface Appliers - that may well be useful in preventing more dynamic types being generated than necessary).
